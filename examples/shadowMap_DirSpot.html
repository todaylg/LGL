<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ShadowMap</title>
    <link href="assets/main.css" rel="stylesheet">
</head>
<body>
    <script type="module">
        import {Renderer, Camera, Transform, Geometry, Program, Mesh, Vec3, Vec4, Mat4, Texture, RenderTarget, Color} from '../src/Core.js';
        import { Orbit, Post, Plane, Sphere, Cube, Torus, ShadowMap } from '../src/Extras.js';
        import shadowMapShader from './shaders/shadowMapShader.js';
        import showDepthShader from './shaders/showDepthShader.js';
        {
            const renderer = new Renderer({dpr: 2});
            const gl = renderer.gl;
            gl.clearColor(1, 1, 1, 1);
            document.body.appendChild(gl.canvas);
            const camera = new Camera({ far:500 });
            camera.position.set(20, 50, -50);
            const controls = new Orbit(camera);
            function resize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.perspective({aspect: gl.canvas.width / gl.canvas.height});
            }
            window.addEventListener('resize', resize, false);
            resize();

            let lightArrConf = [
                {
                    lightType: 'dir',
                    lightPos: new Vec3(0, 20, 0.1),
                    direction: new Vec3(0, -1.0, 0)
                },
                {
                    lightType: 'spot',
                    lightPos: new Vec3(5, 10, 20),
                    direction: new Vec3(-0.2, -1.0, -0.3),
                },
            ]
            //Init Shadow
            let shadowMap = new ShadowMap(gl, lightArrConf);
            let { lightArr } = shadowMap;

            //1.Init Scene 
            const scene = new Transform();
            const cubeGeometry = new Cube(gl);
            const planeGeometry = new Plane(gl, {
                width: 100,
                height: 100
            });
            const sphereGeometry = new Sphere(gl, {
                widthSegments: 64
            });
            const torusGeometry = new Torus(gl, {
                radius: 0.5,
                tube: 0.1,
                radialSegments: 16,
                tubularSegments: 100
            });
            let dirLightSpaceMatrix = [], spotLightSpaceMatrix = [], pointLightSpaceMatrix = [];
            let dirShadowMap = [], spotShadowMap = [], pointShadowMap = [];
            let directionalLights = [], spotLights = [], pointLights = [];
            function initShaderDefines(lightArr){
                let shaderDefines = `#version 300 es\n`;
                let NUM_DIR_LIGHTS = 0, NUM_SPOT_LIGHTS = 0, NUM_POINT_LIGHTS = 0;
                for(let i = 0, l = lightArr.length; i < l; i++){
                    let light = lightArr[i];
                    switch(light.lightType){
                        case 'dir':
                            directionalLights[NUM_DIR_LIGHTS] = {
                                lightPos: light.lightPos,
                                direction: light.direction,
                                lightColor: light.color,
                            };
                            dirShadowMap[NUM_DIR_LIGHTS] = light.depthTexture;
                            dirLightSpaceMatrix[NUM_DIR_LIGHTS] = light.lightSpaceMatrix;
                            NUM_DIR_LIGHTS++;
                        break;
                        case 'spot':
                            spotLights[NUM_SPOT_LIGHTS] = { 
                                lightPos: light.lightPos,
                                direction: light.direction,
                                lightColor: light.color,
                                constant: 1,
                                linear: 0.09,
                                quadratic: 0.032,
                                cutOff: Math.cos(12.5),
                                outerCutOff: Math.cos(15),
                            };
                            spotShadowMap[NUM_SPOT_LIGHTS] = light.depthTexture;
                            spotLightSpaceMatrix[NUM_SPOT_LIGHTS] = light.lightSpaceMatrix;
                            NUM_SPOT_LIGHTS++;
                        break;
                        case 'point':
                            pointShadowMap[NUM_POINT_LIGHTS] = light.depthTexture;
                            pointLightSpaceMatrix[NUM_POINT_LIGHTS] = light.lightSpaceMatrix;
                            NUM_POINT_LIGHTS++;
                        break;
                    }
                }
                return shaderDefines += 
                `#define NUM_DIR_LIGHTS ${NUM_DIR_LIGHTS}\n`+
                `#define NUM_SPOT_LIGHTS ${NUM_SPOT_LIGHTS}\n`+
                `#define NUM_POINT_LIGHTS ${NUM_POINT_LIGHTS}\n` +
                `#define SHADOWMAP_TYPE_PCF 1\n`;
            }
            let shaderDefines = initShaderDefines(lightArr);

            //input => lightSpaceMatrix + depthMap + struct light
            const program = new Program(gl, {
                vertex: shaderDefines + shadowMapShader.vertex,
                fragment: shaderDefines + shadowMapShader.fragment,
                uniforms: {
                    baseColor: { value: new Color(1) },
                    ambientLightColor: { value: new Color(1) },
                    ambientStrength: { value: .05 },

                    directionalLights: { value: directionalLights },
                    dirLightSpaceMatrix: {value: dirLightSpaceMatrix},
                    dirShadowMap:{ value: dirShadowMap },

                    spotLights: { value: spotLights },
                    spotLightSpaceMatrix: {value: spotLightSpaceMatrix},
                    spotShadowMap:{ value: spotShadowMap },

                    // pointLights: { value: .2 },
                    pointLightSpaceMatrix: {value: pointLightSpaceMatrix},
                    pointShadowMap: {value: pointShadowMap},

                    cameraNear: { value: camera.near },
					cameraFar:  { value: camera.far },
                }
            });
            const planeMesh = new Mesh(gl, { geometry: planeGeometry, program });
            const cubeMesh = new Mesh(gl, { geometry: cubeGeometry, program });
            const sphereMesh = new Mesh(gl, { geometry: sphereGeometry, program });
            const torusMesh = new Mesh(gl, { geometry: torusGeometry, program });

            planeMesh.rotation.x = - Math.PI / 2;
            planeMesh.setParent(scene);

            cubeMesh.position.y = 10;
            cubeMesh.scale.set(4);
            cubeMesh.castShadowMap = true;
            cubeMesh.setParent(scene);

            torusMesh.position.x = 10;
            torusMesh.position.y = 10;
            torusMesh.scale.set(4);
            torusMesh.castShadowMap = true;
            torusMesh.setParent(scene);

            sphereMesh.position.x = -10;
            sphereMesh.position.y = 10;
            sphereMesh.scale.set(4);
            sphereMesh.castShadowMap = true;
            sphereMesh.setParent(scene);

            //3.(option)Post to Show depthMap
            const post = new Post(gl);
            post.addPass({
                fragment: showDepthShader.fragment,
                uniforms: {
                    tMap: { value: spotShadowMap[0] },
                    cameraNear: { value: camera.near },
					cameraFar:  { value: camera.far },
                }
            });
          
            let startTime = performance.now();
            let tick = 0;
            requestAnimationFrame(update);
            function update(t) {
                let now = performance.now();
                let delta = .001 * (now - startTime);
                startTime = now;
                tick += delta;
                cubeMesh.rotation.y += 0.01;
                torusMesh.rotation.y += 0.01;
                controls.update();
                shadowMap.render(scene);
                // post.render({scene, camera}); //See The Depth Texture
                renderer.render({scene, camera});
                requestAnimationFrame(update);
            }
        }
    </script>
</body>
</html>