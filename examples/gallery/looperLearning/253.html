<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimal-ui, viewport-fit=cover, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <title>Universe</title>
    <link href="../../assets/main.css" rel="stylesheet">
</head>

<body class="blackBG">
    <canvas class="canvas2D"></canvas>
    <script type="module">
        import { Renderer, Geometry, Program, Mesh, Camera, Transform, Texture, Color, Vec3, Vec2, RenderTarget } from '../../../src/Core.js';
        import { Plane, Sphere, Orbit, Torus, Post } from '../../../src/Extras.js';
        import sphereShader from './253/sphereShader.js';
        import torusShader from './253/torusShader.js';
        import baseShader from './253/baseShader.js';
        import discShader from './253/discShader.js';
        import glowShader from './253/glowShader.js';
        import particlesShader from './253/particlesShader.js';
        import blurFragmentShader from './253/blurFragmentShader.js';
        import combineFragmentShader from './253/combineFragmentShader.js';
        import { TAU, randomInRange, parabola, sphericalToCartesian, loadAllImages } from '../../assets/js/Util.js';
        import ShaderPingPongPass from '../shaders/shader-ping-pong-pass.js';
        import ShaderPass from '../shaders/shader-pass.js';
        import LGPreLoading from '../../assets/js/LGPreLoading.js';
        {
            const renderer = new Renderer({ dpr: 2 });
            const gl = renderer.gl;
            document.body.appendChild(gl.canvas);
            gl.canvas.classList.add("canvas3d");
            gl.clearColor(0, 0, 0, 0);
            const camera = new Camera({ fov: 45 });
            const center = new Vec3([0, 0, 20]);
            camera.position.copy(center);

            function resize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.perspective({ aspect: gl.canvas.width / gl.canvas.height })
            }
            window.addEventListener('resize', resize, false);
            resize();
            //0.Load Image Source
            let preloadEle = document.querySelector('.canvas2D');
            let preLoading = new LGPreLoading(preloadEle);
            const starTexture = new Texture(gl);
            const noiseTexture = new Texture(gl);
            const particalTexture = new Texture(gl);
            const earthTexture = new Texture(gl);
            loadAllImages(['253/stars.jpg', '253/swirl.jpg', '253/dust.png','253/earth.jpg']).then(([starImg, swirlImg, dustImg, earthImg]) => {
                starTexture.image = starImg;
                noiseTexture.image = swirlImg;
                particalTexture.image = dustImg;
                earthTexture.image = earthImg;
                preLoading.finish(() => {
                    preloadEle.classList.add("hide");
                    gl.canvas.classList.add("show");
                    setTimeout(() => {
                        preloadEle.remove();
                        preLoading.destroy();
                    }, 2000);
                })
            })

            const scene = new Transform();
            const group = new Transform();
            const blackHole = new Transform();
            const blackHoleRadius = 2;

            let lightColor = new Color([0.807, 0.99, 1]);
            let ambientLightColor = new Color([0.313, 0.313, 0.313]);
            let ambientStrength = 0.5;

            //1.StarBG
            // Use Sphere geometry to render equirectangular textures
            const sphereGeometry = new Sphere(gl, 1, 64);
            const sphereProgram = new Program(gl, {
                vertex: sphereShader.vertex,
                fragment: sphereShader.fragment,
                uniforms: {
                    tMap: { value: starTexture },
                    ambientLightColor: { value: ambientLightColor },
                    ambientStrength: 0.5
                },
                cullFace: null
            });
            const skySphere = new Mesh(gl, { geometry: sphereGeometry, program: sphereProgram });
            skySphere.scale.set(60);
            group.addChild(skySphere);
            const earthProgram = new Program(gl, {
                vertex: sphereShader.vertex,
                fragment: sphereShader.fragment,
                uniforms: {
                    tMap: { value: earthTexture },
                    ambientLightColor: { value: ambientLightColor },
                    ambientStrength: 0.5
                },
                cullFace: null
            });
            const earthSphere = new Mesh(gl, { geometry: sphereGeometry, program: earthProgram });
            earthSphere.position.set(10,0,10);
            group.addChild(earthSphere);
            //2.CenterTorus
            const torusGeometry = new Torus(gl, 2, 2, 36, 100);
            const torusProgram = new Program(gl, {
                vertex: torusShader.vertex,
                fragment: torusShader.fragment,
                uniforms: {
                    tMap: { value: starTexture },
                },
                transparent: true
            });
            const torus = new Mesh(gl, { geometry: torusGeometry, program: torusProgram });
            blackHole.addChild(torus);
            //3.CenterSphere
            const basicProgram = new Program(gl, {
                vertex: baseShader.vertex,
                fragment: baseShader.fragment,
                uniforms: {
                    lightColor: { value: lightColor },
                    ambientLightColor: { value: ambientLightColor },
                    ambientStrength: { value: ambientStrength },
                    baseColor: { value: new Color([0, 0, 0]) }
                },
            })
            const body = new Mesh(gl, { geometry: new Sphere(gl, blackHoleRadius, 64), program: basicProgram });
            blackHole.addChild(body);
            //4.DiscPart1
            const discProgram = new Program(gl, {
                vertex: discShader.vertex,
                fragment: discShader.fragment,
                uniforms: {
                    radius: { value: blackHoleRadius },
                    max: { value: 0 },
                    repeat: { value: 0 },
                    noiseTexture: { value: noiseTexture },
                    time: { value: 0 },
                    opacity: { value: .25 }
                },
                transparent: true,
                depthWrite: false,
                cullFace: null,
            });
            const discRadius1 = 2;
            const disc1 = new Mesh(gl, {
                geometry: new Torus(gl, blackHoleRadius + discRadius1, discRadius1, 36, 100),
                program: discProgram
            });
            disc1.scale.z = .1;
            disc1.program.uniforms.repeat.value = 3;
            disc1.program.uniforms.radius.value = blackHoleRadius;
            disc1.program.uniforms.max.value = discRadius1;
            //blackHole.addChild(disc1);
            //5.DiscPart2
            const discRadius2 = 20;
            const disc2 = new Mesh(gl, {
                geometry: new Torus(gl, blackHoleRadius + discRadius2, discRadius2, 36, 100),
                program: discProgram
            })
            disc2.program.uniforms.noiseTexture.value = noiseTexture;
            disc2.program.uniforms.repeat.value = 10;
            disc2.program.uniforms.radius.value = blackHoleRadius;
            disc2.program.uniforms.max.value = discRadius2;
            disc2.program.uniforms.opacity.value = .5;
            disc2.rotation.x = Math.PI / 2;
            disc2.scale.z = .01;
            group.addChild(disc2);

            //6.Partical
            const particalNum = 5000;
            const particlPos = new Float32Array(particalNum * 3);
            for (let i = 0; i < particalNum; i++) {
                const r = randomInRange(blackHoleRadius, blackHoleRadius + .5 * discRadius2);
                const theta = randomInRange(0, TAU);
                const phi = randomInRange(-.1, .1);
                const p = sphericalToCartesian(r, theta, phi);
                particlPos[i * 3] = p.x;
                particlPos[i * 3 + 1] = p.y;
                particlPos[i * 3 + 2] = p.z;
            }

            const particalGeometry = new Geometry(gl, {
                position: { size: 3, data: particlPos },
            });

            const particalProgram = new Program(gl, {
                vertex: particlesShader.vertex,
                fragment: particlesShader.fragment,
                uniforms: {
                    size: { value: 1 },
                    tMap: { value: particalTexture },
                    baseColor: { value: new Color().setHSL(1.0, 0.3, 0.7) }
                },
                depthWrite: false,
                transparent: true,
            });

            // Make sure mode is gl.POINTS
            const particles = new Mesh(gl, { mode: gl.POINTS, geometry: particalGeometry, program: particalProgram });
            group.addChild(particles);

            const glowRadius = 20;
            const glowProgram = new Program(gl, {
                uniforms: {
                    max: { value: glowRadius / 2 },
                },
                vertex: glowShader.vertex,
                fragment: glowShader.fragment,
                transparent: true,
            });
            const glow = new Mesh(gl, {
                geometry: new Plane(gl, glowRadius, glowRadius),
                program: glowProgram
            });
            blackHole.addChild(glow);
            scene.addChild(blackHole);
            scene.addChild(group);

            const loopDuration = 15;
            const startTime = performance.now();
            //7.Post
            const post = new Post(gl);
            const backFBO = new RenderTarget(gl);
            const glowFBO = new RenderTarget(gl);
            const discFBO = new RenderTarget(gl);
            const blurPasses = [];
            const levels = 5;
            let w = gl.canvas.width;
            let h = gl.canvas.height;
            const blurProgram = new Program(gl, {
                vertex: baseShader.vertex,
                fragment: blurFragmentShader,
                uniforms: {
                    inputTexture: { value: null },
                    resolution: { value: new Vec2([w, h]) },
                    direction: { value: new Vec2([0, 1]) }
                }
            });
            let tw = w;
            let th = h;
            for (let i = 0; i < levels; i++) {
                tw /= 2;
                th /= 2;
                tw = Math.round(tw);
                th = Math.round(th);
                const blurPass = new ShaderPingPongPass(renderer, blurProgram, tw, th);
                blurPasses.push(blurPass);
            }
            const combineShader = new Program(gl, {
                vertex: baseShader.vertex,
                fragment: combineFragmentShader,
                uniforms: {
                    backTexture: { value: backFBO.texture },
                    discTexture: { value: discFBO.texture },
                    glowTexture: { value: glowFBO.texture },
                    blur1Texture: { value: blurPasses[0].texture },
                    blur2Texture: { value: blurPasses[1].texture },
                    blur3Texture: { value: blurPasses[2].texture },
                    blur4Texture: { value: blurPasses[3].texture },
                    blur5Texture: { value: blurPasses[4].texture },
                    resolution: { value: new Vec2([w, h]) },
                    vignetteBoost: { value: .5 },
                    vignetteReduction: { value: .5 },
                },
            });
            const combinePass = new ShaderPass(renderer, combineShader, w, h);

            function postRender(scene, camera) {
                skySphere.visible = true;
                torus.visible = true;
                body.visible = true;
                glow.visible = false;
                disc1.visible = false;
                disc2.visible = false;
                renderer.render({ scene, camera, target: backFBO });

                skySphere.visible = false;
                torus.visible = false;
                glow.visible = false;
                disc1.visible = true;
                disc2.visible = true;
                renderer.render({ scene, camera, target: discFBO });

                skySphere.visible = false;
                torus.visible = false;
                glow.visible = true;
                disc1.visible = false;
                disc2.visible = false;
                renderer.render({ scene, camera, target: glowFBO });

                let offset = 3;

                blurProgram.uniforms.inputTexture.value = discFBO;
                for (let j = 0; j < levels; j++) {
                    blurProgram.uniforms.direction.value.set(offset, 0);
                    const blurPass = blurPasses[j];
                    blurPass.render();
                    blurProgram.uniforms.inputTexture.value = blurPass.fbos[blurPass.currentFBO];
                    blurProgram.uniforms.direction.value.set(0, offset);
                    blurPass.render();
                    blurProgram.uniforms.inputTexture.value = blurPass.fbos[blurPass.currentFBO];
                }

                combinePass.render(true);
            }
            requestAnimationFrame(update);
            function update() {
                const time = (.001 * (performance.now() - startTime)) % loopDuration;
                const t = time / loopDuration;
                //disc1.program.uniforms.time.value = t;
                //disc2.program.uniforms.time.value = t;

                camera.position.copy(center);
                camera.position.x += 3 * Math.sin(t * TAU);
                camera.position.y += 3.5 * Math.cos(t * TAU);
                camera.lookAt(blackHole.position);
                camera.rotation.z = .01 * TAU;
                blackHole.lookAt(camera.position);
                earthSphere.rotation.x = t * TAU/2;
                group.rotation.y = t * TAU;
                postRender(scene, camera);
                requestAnimationFrame(update);
            }
        }
    </script>
</body>

</html>