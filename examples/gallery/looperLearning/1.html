<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimal-ui, viewport-fit=cover, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <title>Cube</title>
    <link href="../../assets/main.css" rel="stylesheet">
</head>

<body>
    <script type="module">
        import { Renderer, Camera, Transform, Program, Mesh, Vec3, Color } from '../../../src/Core.js';
        import { Cube, Orbit } from '../../../src/Extras.js';
        import BasePrimitivesShader from '../shaders/baseShader.js';
        import Noise from '../../assets/js/perlin.js';

        {
            let noise = new Noise();
            noise.seed(0);
            const renderer = new Renderer({ dpr: 2 });
            const gl = renderer.gl;
            document.body.appendChild(gl.canvas);
            gl.clearColor(1, 1, 1, 1);

            const camera = new Camera(gl, { fov: 35 });
            camera.position.set(5.5, 8, 5.5);
            camera.lookAt([0, 0, 0]);

            const controls = new Orbit(camera);

            function resize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.perspective({ aspect: gl.canvas.width / gl.canvas.height })
            }
            window.addEventListener('resize', resize, false);
            resize();

            const scene = new Transform();
            const group = new Transform();

            const SIZE = 4;
            const cubes = [];
            for (let y = 0; y < SIZE; y++) {
                for (let x = 0; x < SIZE; x++) {
                    for (let j = 0; j < 10; j++) {
                        const cubeGeometry = new Cube(gl);
                        const program = new Program(gl, {
                            vertex: BasePrimitivesShader.vertex,
                            fragment: BasePrimitivesShader.fragment,
                            uniforms: {
                                lightColor: { value: new Color([0.807, 0.99, 1]) },
                                ambientLightColor: { value: new Color([0.313, 0.313, 0.313])  },
                                ambientStrength: { value: 0.5 },
                                baseColor: { value: new Color([1, 1, 1]) }
                            }
                        });
                        const mesh = new Mesh(gl, { geometry: cubeGeometry, program });
                        mesh.position.set(-.5 * SIZE, y - .5 * SIZE, x - .5 * SIZE);
                        mesh.position.z += 1;
                        cubes.push({ mesh, x, y, offset: Math.random() });
                        group.addChild(mesh);
                    }
                }
            }
            scene.addChild(group);
            group.rotation.z = Math.PI / 2;

            const loopDuration = 2;

            //抛物线
            function parabola(x, k) {
                return Math.pow(4 * x * (1 - x), k);
            }
            const s = 4;
            const DEPTH = 5;
            let startTime = performance.now();
            function renderScence(t) {
                const time = (.001 * (t - startTime)) % loopDuration;
                cubes.forEach(c => {
                    const t = ((time + c.offset * loopDuration) % loopDuration) / loopDuration;
                    c.mesh.position.x = .5 - .5 * DEPTH + t * DEPTH;
                    const n = .25 + .25 * (noise.perlin3(s * t, s * c.mesh.position.y, s * c.mesh.position.z));
                    const tz = (c.mesh.position.z + .5 * SIZE) / SIZE;
                    const finalScale = 1.5 * parabola(t, 1) * n;
                    c.mesh.program.uniforms.baseColor.value.setHSL(.5 + .5 * finalScale, .4 + .2 * tz, .4 + .2 * tz);
                    c.mesh.scale.set(finalScale);
                })
            }

            requestAnimationFrame(update);
            function update(t) {
                renderScence(t);
                controls.update();
                renderer.render({ scene, camera });
                requestAnimationFrame(update);
            }
        }
    </script>
</body>

</html>