<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimal-ui, viewport-fit=cover, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
    <title>Sakura</title>
    <link href="../assets/main.css" rel="stylesheet">
</head>

<body>
    <script type="module">
        import { Renderer, Camera, Transform, Program, Mesh, Geometry, Vec3 } from '../../src/Core.js';
        import { Plane } from '../../src/Extras.js';
        import BlossomParticle from './Sakura/BlossomParticle.js';
        import sakuraPointShader from './Sakura/shaders/sakuraPoint.js';
        {
            const renderer = new Renderer({ dpr: 2 });
            const gl = renderer.gl;
            document.body.appendChild(gl.canvas);
            gl.clearColor(1, 1, 1, 1);
            const camera = new Camera(gl, { fov: 35 });
            camera.position.set(0, 1, 7);
            camera.lookAt([0, 0, 0]);
            let timeInfo = {
                'start': 0, 'prev': 0, // Date
                'delta': 0, 'elapsed': 0 // Number(sec)
            };
            timeInfo.start = new Date();
            timeInfo.prev = timeInfo.start;
            let renderSpec = {
                'width': 0,
                'height': 0,
                'aspect': 1,
                'array': new Float32Array(3),
                'halfWidth': 0,
                'halfHeight': 0,
                'halfArray': new Float32Array(3)
            };
            renderSpec.setSize = function (w, h) {
                renderSpec.width = w;
                renderSpec.height = h;
                renderSpec.aspect = renderSpec.width / renderSpec.height;
                renderSpec.array[0] = renderSpec.width;
                renderSpec.array[1] = renderSpec.height;
                renderSpec.array[2] = renderSpec.aspect;

                renderSpec.halfWidth = Math.floor(w / 2);
                renderSpec.halfHeight = Math.floor(h / 2);
                renderSpec.halfArray[0] = renderSpec.halfWidth;
                renderSpec.halfArray[1] = renderSpec.halfHeight;
                renderSpec.halfArray[2] = renderSpec.halfWidth / renderSpec.halfHeight;
            };
            function resize() {
                renderSpec.setSize(gl.canvas.width, gl.canvas.height);
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.perspective({ aspect: gl.canvas.width / gl.canvas.height })
            }
            window.addEventListener('resize', resize, false);
            resize();

            const scene = new Transform();
            //
            //createPointFlowers
            let pointFlower = {};
            pointFlower.numFlowers = 100;
            pointFlower.offset = new Float32Array([0.0, 0.0, 0.0]);
            pointFlower.fader = new Vec3([0.0, 10.0, 0.0]);
            pointFlower.particles = new Array(pointFlower.numFlowers);
            for (var i = 0; i < pointFlower.numFlowers; i++) {
                pointFlower.particles[i] = new BlossomParticle();
            }
            pointFlower.positionData = new Float32Array(pointFlower.numFlowers * 3);
            pointFlower.eulerData = new Float32Array(pointFlower.numFlowers * 3);
            pointFlower.miscData = new Float32Array(pointFlower.numFlowers * 2);
            const flowerProgram = new Program(gl, {
                vertex: sakuraPointShader.vertex,
                fragment: sakuraPointShader.fragment,
                uniforms: {
                    uResolution: { value: renderSpec.array },
                    uOffset: { value: pointFlower.offset },
                    uFade: { value: pointFlower.fader },
                    uDOF: { value: new Vec3([10.0, 4.0, 8.0]),}
                },
            });
            const flowerGeometry = new Geometry(gl, {
                aPosition: { size: 3, data: pointFlower.positionData },
                aEuler: { size: 3, data: pointFlower.eulerData },
                aMisc: { size: 3, data: pointFlower.miscData }
            });
            let flowerMesh = new Mesh(gl, { geometry: flowerGeometry, program: flowerProgram });
            flowerMesh.setParent(scene);
            //init PointFlowers 
            pointFlower.area = new Vec3([20.0, 20.0, 20.0]);
            pointFlower.area.x = pointFlower.area.y * renderSpec.aspect;

            //particles
            const PI2 = Math.PI * 2.0;
            let tmpv3 = new Vec3();
            let tmpv = 0;
            let symmetryrand = function () { return (Math.random() * 2.0 - 1.0); };
            for (let i = 0; i < pointFlower.numFlowers; i++) {
                let tmpprtcl = pointFlower.particles[i];

                //velocity
                tmpv3.x = symmetryrand() * 0.3 + 0.8;
                tmpv3.y = symmetryrand() * 0.2 - 1.0;
                tmpv3.z = symmetryrand() * 0.3 + 0.5;
                tmpv3.normalize();
                tmpv = 5.0 + Math.random() * 1.0;
                tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv);

                //rotation
                tmpprtcl.setRotation(
                    symmetryrand() * PI2 * 0.5,
                    symmetryrand() * PI2 * 0.5,
                    symmetryrand() * PI2 * 0.5
                );

                //position
                tmpprtcl.setPosition(
                    symmetryrand() * pointFlower.area.x,
                    symmetryrand() * pointFlower.area.y,
                    symmetryrand() * pointFlower.area.z
                );

                //euler
                tmpprtcl.setEulerAngles(
                    Math.random() * Math.PI * 2.0,
                    Math.random() * Math.PI * 2.0,
                    Math.random() * Math.PI * 2.0
                );

                //size
                tmpprtcl.setSize(0.4 + Math.random() * 0.1);
            }
            //renderPointFlowers
            function renderPointFlowers() {
                //update
                let PI2 = Math.PI * 2.0;
                let limit = [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z];
                let repeatPos = function (prt, cmp, limit) {
                    if (Math.abs(prt.position[cmp]) - prt.size * 0.5 > limit) {
                        //out of area
                        if (prt.position[cmp] > 0) {
                            prt.position[cmp] -= limit * 2.0;
                        }
                        else {
                            prt.position[cmp] += limit * 2.0;
                        }
                    }
                };
                let repeatEuler = function (prt, cmp) {
                    prt.euler[cmp] = prt.euler[cmp] % PI2;
                    if (prt.euler[cmp] < 0.0) {
                        prt.euler[cmp] += PI2;
                    }
                };

                for (let i = 0; i < pointFlower.numFlowers; i++) {
                    let prtcl = pointFlower.particles[i];
                    prtcl.update(timeInfo.delta, timeInfo.elapsed);
                    repeatPos(prtcl, 0, pointFlower.area.x);
                    repeatPos(prtcl, 1, pointFlower.area.y);
                    repeatPos(prtcl, 2, pointFlower.area.z);
                    repeatEuler(prtcl, 0);
                    repeatEuler(prtcl, 1);
                    repeatEuler(prtcl, 2);

                    prtcl.alpha = 1.0;//(pointFlower.area.z - prtcl.position[2]) * 0.5;

                    prtcl.zkey = (camera.matrix[2] * prtcl.position[0]
                        + camera.matrix[6] * prtcl.position[1]
                        + camera.matrix[10] * prtcl.position[2]
                        + camera.matrix[14]);
                }

                // sort
                pointFlower.particles.sort(function (p0, p1) { return p0.zkey - p1.zkey; });

                // update data
                let ipos = pointFlower.positionArrayOffset;
                let ieuler = pointFlower.eulerArrayOffset;
                let imisc = pointFlower.miscArrayOffset;
                for (let i = 0; i < pointFlower.numFlowers; i++) {
                    let prtcl = pointFlower.particles[i];
                    pointFlower.positionData[ipos] = prtcl.position[0];
                    pointFlower.positionData[ipos + 1] = prtcl.position[1];
                    pointFlower.positionData[ipos + 2] = prtcl.position[2];
                    ipos += 3;
                    pointFlower.eulerData[ieuler] = prtcl.euler[0];
                    pointFlower.eulerData[ieuler + 1] = prtcl.euler[1];
                    pointFlower.eulerData[ieuler + 2] = prtcl.euler[2];
                    ieuler += 3;
                    pointFlower.miscData[imisc] = prtcl.size;
                    pointFlower.miscData[imisc + 1] = prtcl.alpha;
                    imisc += 2;
                }
            }

            requestAnimationFrame(update);
            function update() {
                let curdate = new Date();
                timeInfo.elapsed = (curdate - timeInfo.start) / 1000.0;
                timeInfo.delta = (curdate - timeInfo.prev) / 1000.0;
                timeInfo.prev = curdate;
                renderPointFlowers();
                requestAnimationFrame(update);
                renderer.render({ scene, camera });
            }
        }
    </script>
</body>

</html>